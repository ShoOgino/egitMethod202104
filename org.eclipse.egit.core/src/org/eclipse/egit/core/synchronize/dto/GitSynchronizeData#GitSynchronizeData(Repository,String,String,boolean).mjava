	/**
	 * Constructs {@link GitSynchronizeData} object
	 *
	 * @param repository
	 * @param srcRev
	 * @param dstRev
	 * @param includeLocal
	 *            <code>true</code> if local changes should be included in
	 *            comparison
	 * @throws IOException
	 */
	public GitSynchronizeData(Repository repository, String srcRev,
			String dstRev, boolean includeLocal) throws IOException {
		isNotNull(repository);
		isNotNull(srcRev);
		isNotNull(dstRev);
		repo = repository;

		srcRemote = extractRemoteName(srcRev);
		dstRemote = extractRemoteName(dstRev);

		ObjectWalk ow = new ObjectWalk(repo);
		if (srcRev.length() > 0)
			this.srcRevCommit = ow.parseCommit(repo.resolve(srcRev));
		else
			this.srcRevCommit = null;

		if (dstRev.length() > 0)
			this.dstRevCommit = ow.parseCommit(repo.resolve(dstRev));
		else
			this.dstRevCommit = null;

		if (this.dstRevCommit != null || this.srcRevCommit != null)
			this.ancestorRevCommit = getCommonAncestor(repo, this.srcRevCommit,
					this.dstRevCommit);
		else
			this.ancestorRevCommit = null;

		this.includeLocal = includeLocal;
		repoParentPath = repo.getDirectory().getParentFile().getAbsolutePath();

		projects = new HashSet<IProject>();
		final IProject[] workspaceProjects = ROOT.getProjects();
		for (IProject project : workspaceProjects) {
			RepositoryMapping mapping = RepositoryMapping.getMapping(project);
			if (mapping != null && mapping.getRepository() == repo)
				projects.add(project);
		}

	}

