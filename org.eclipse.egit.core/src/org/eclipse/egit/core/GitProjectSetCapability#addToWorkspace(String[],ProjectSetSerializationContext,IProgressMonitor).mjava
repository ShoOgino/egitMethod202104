	@Override
	public IProject[] addToWorkspace(final String[] referenceStrings,
			final ProjectSetSerializationContext context,
			final IProgressMonitor monitor) throws TeamException {
		final Map<URIish, Map<String, Set<ProjectReference>>> repositories =
				new LinkedHashMap<URIish, Map<String, Set<ProjectReference>>>();
		for (final String reference : referenceStrings) {
			try {
				final ProjectReference projectReference = new ProjectReference(
						reference);
				Map<String, Set<ProjectReference>> repositoryBranches = repositories
						.get(projectReference.repository);
				if (repositoryBranches == null) {
					repositoryBranches = new HashMap<String, Set<ProjectReference>>();
					repositories.put(projectReference.repository,
							repositoryBranches);
				}
				Set<ProjectReference> projectReferences = repositoryBranches.get(projectReference.branch);
				if (projectReferences == null) {
					projectReferences = new TreeSet<ProjectReference>(new ProjectReferenceComparator());
					repositoryBranches.put(projectReference.branch, projectReferences);
				}

				projectReferences.add(projectReference);
			} catch (final IllegalArgumentException e) {
				throw new TeamException(reference, e);
			} catch (final URISyntaxException e) {
				throw new TeamException(reference, e);
			}
		}
		final ArrayList<IProject> importedProjects = new ArrayList<IProject>();
		for (final URIish gitUrl : repositories.keySet()) {
			Map<String, Set<ProjectReference>> branches = repositories
					.get(gitUrl);
			for (final String branch : branches.keySet()) {
				final Set<ProjectReference> projects = branches.get(branch);
				try {
					final IPath workDir = getWorkingDir(gitUrl, branch,
							branches.keySet());
					if (workDir.toFile().exists()) {
						final Collection<String> projectNames = new LinkedList<String>();
						for (final ProjectReference projectReference : projects)
							projectNames.add(projectReference.projectDir);
						throw new TeamException(NLS.bind(
								CoreText.GitProjectSetCapability_CloneToExistingDirectory,
								new Object[] { workDir, projectNames, gitUrl }));
					}

					int timeout = 60;
					String refName = Constants.R_HEADS + branch;
					final CloneOperation cloneOperation = new CloneOperation(
							gitUrl, true, null, workDir.toFile(), refName,
							Constants.DEFAULT_REMOTE_NAME, timeout);
					cloneOperation.run(monitor);

					final File repositoryPath = workDir.append(Constants.DOT_GIT_EXT).toFile();

					Activator.getDefault().getRepositoryUtil().addConfiguredRepository(repositoryPath);

					// import projects from the current repository to workspace
					final IWorkspace workspace = ResourcesPlugin.getWorkspace();
					final IWorkspaceRoot root = workspace.getRoot();
					for (final ProjectReference projectToImport : projects) {
						final IPath projectDir = workDir
								.append(projectToImport.projectDir);
						final IProjectDescription projectDescription = workspace
								.loadProjectDescription(projectDir
										.append(IProjectDescription.DESCRIPTION_FILE_NAME));
						final IProject project = root
								.getProject(projectDescription.getName());
						project.create(projectDescription, monitor);
						importedProjects.add(project);

						project.open(monitor);
						final ConnectProviderOperation connectProviderOperation = new ConnectProviderOperation(
								project, repositoryPath);
						connectProviderOperation.execute(monitor);
					}
				} catch (final InvocationTargetException e) {
					throw TeamException.asTeamException(e);
				} catch (final CoreException e) {
					throw TeamException.asTeamException(e);
				} catch (final InterruptedException e) {
					// was canceled by user
					return new IProject[0];
				}
			}
		}
		final IProject[] result = importedProjects
				.toArray(new IProject[importedProjects.size()]);
		return result;
	}

