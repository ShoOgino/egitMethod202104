	private void doCheckout(final IProgressMonitor monitor) throws IOException {
		if (ref == null)
			return;
		final Ref head = fetchResult.getAdvertisedRef(ref.getName());
		if (head == null || head.getObjectId() == null)
			return;

		final RevWalk rw = new RevWalk(local);
		final RevCommit mapCommit;
		try {
			mapCommit = rw.parseCommit(head.getObjectId());
		} finally {
			rw.release();
		}

		final RefUpdate u;

		boolean detached = !head.getName().startsWith(Constants.R_HEADS);
		u = local.updateRef(Constants.HEAD, detached);
		u.setNewObjectId(mapCommit.getId());
		u.forceUpdate();

		monitor.setTaskName(CoreText.CloneOperation_checkingOutFiles);
		DirCacheCheckout dirCacheCheckout = new DirCacheCheckout(
				local, null, local.lockDirCache(), mapCommit.getTree());
		dirCacheCheckout.setFailOnConflict(true);
		boolean result = dirCacheCheckout.checkout();
		if (!result)
			// this should never happen when writing in an empty folder
			throw new IOException("Internal error occured on checking out files"); //$NON-NLS-1$
		monitor.setTaskName(CoreText.CloneOperation_writingIndex);
	}

