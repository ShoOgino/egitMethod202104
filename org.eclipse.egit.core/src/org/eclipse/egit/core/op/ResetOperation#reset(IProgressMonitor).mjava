	private void reset(IProgressMonitor monitor) throws CoreException {
		monitor.beginTask(NLS.bind(CoreText.ResetOperation_performingReset,
				type.toString().toLowerCase(), refName), 3);

		IProject[] validProjects = null;
		if (type == ResetType.HARD)
			validProjects = ProjectUtil.getValidOpenProjects(repository);
		boolean merging = false;
		if (repository.getRepositoryState().equals(RepositoryState.MERGING)
				|| repository.getRepositoryState().equals(
						RepositoryState.MERGING_RESOLVED))
			merging = true;
		final boolean cherryPicking = repository.getRepositoryState().equals(RepositoryState.CHERRY_PICKING)
			|| repository.getRepositoryState().equals(RepositoryState.CHERRY_PICKING_RESOLVED);

		mapObjects();
		monitor.worked(1);

		writeRef();
		monitor.worked(1);

		switch (type) {
		case HARD:
			checkoutIndex();
			monitor.worked(1);
			if (merging)
				resetMerge();
			if (cherryPicking)
				resetCherryPick();
			monitor.worked(1);
			// only refresh if working tree changes
			ProjectUtil.refreshValidProjects(validProjects, new SubProgressMonitor(
					monitor, 1));
			monitor.worked(1);
			break;

		case MIXED:
			// Change the
			resetIndex();
			monitor.worked(2);
			if (merging)
				resetMerge();
			if (cherryPicking)
				resetCherryPick();
			monitor.worked(1);
			break;

		case SOFT:
			// only change the ref
			monitor.worked(3);
		}
		monitor.done();
	}

