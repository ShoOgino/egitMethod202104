	@Override
	public void execute(IProgressMonitor m) throws CoreException {
		IWorkspaceRunnable action = new IWorkspaceRunnable() {

			@Override
			public void run(IProgressMonitor pm) throws CoreException {
				SubMonitor progress = SubMonitor.convert(pm, 4);
				preExecute(progress.newChild(1));

				IProject[] missing = getMissingProjects(target, ProjectUtil
						.getValidOpenProjects(repository));

				progress.setTaskName(NLS.bind(
						CoreText.BranchOperation_performingBranch, target));
				progress.setWorkRemaining(missing.length > 0 ? 4 : 3);

				if (missing.length > 0) {
					SubMonitor closeMonitor = progress.newChild(1);
					closeMonitor.setWorkRemaining(missing.length);
					for (IProject project : missing) {
						closeMonitor.subTask(MessageFormat.format(
								CoreText.BranchOperation_closingMissingProject,
								project.getName()));
						project.close(closeMonitor.newChild(1));
					}
				}

				CheckoutCommand co = new Git(repository).checkout();
				co.setName(target);

				try {
					co.call();
				} catch (CheckoutConflictException e) {
					return;
				} catch (JGitInternalException e) {
					throw new CoreException(Activator.error(e.getMessage(), e));
				} catch (GitAPIException e) {
					throw new CoreException(Activator.error(e.getMessage(), e));
				} finally {
					BranchOperation.this.result = co.getResult();
				}
				if (result.getStatus() == Status.NONDELETED)
					retryDelete(result.getUndeletedList());
				progress.worked(1);

				List<String> pathsToHandle = new ArrayList<String>();
				pathsToHandle.addAll(co.getResult().getModifiedList());
				pathsToHandle.addAll(co.getResult().getRemovedList());
				pathsToHandle.addAll(co.getResult().getConflictList());
				IProject[] refreshProjects = ProjectUtil
						.getProjectsContaining(repository, pathsToHandle);
				ProjectUtil.refreshValidProjects(refreshProjects, delete,
						progress.newChild(1));

				postExecute(progress.newChild(1));
			}
		};
		// lock workspace to protect working tree changes
		ResourcesPlugin.getWorkspace().run(action, getSchedulingRule(),
				IWorkspace.AVOID_UPDATE, m);
	}

