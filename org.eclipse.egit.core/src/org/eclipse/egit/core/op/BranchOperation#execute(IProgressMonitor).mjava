	@Override
	public void execute(IProgressMonitor m) throws CoreException {
		IWorkspaceRunnable action = new IWorkspaceRunnable() {

			@Override
			public void run(IProgressMonitor pm) throws CoreException {
				SubMonitor progress = SubMonitor.convert(pm, 4);
				preExecute(progress.newChild(1));

				closeProjectsMissingAfterCheckout(progress);

				try (Git git = new Git(repository)) {
					CheckoutCommand co = git.checkout();
					co.setName(target);

					try {
						co.call();
					} catch (CheckoutConflictException e) {
						return;
					} catch (JGitInternalException e) {
						throw new CoreException(
								Activator.error(e.getMessage(), e));
					} catch (GitAPIException e) {
						throw new CoreException(
								Activator.error(e.getMessage(), e));
					} finally {
						result = co.getResult();
					}
					if (result.getStatus() == Status.NONDELETED) {
						retryDelete(result.getUndeletedList());
					}
					progress.worked(1);
					refreshAffectedProjects(progress);

					postExecute(progress.newChild(1));
				}
			}

			private void closeProjectsMissingAfterCheckout(SubMonitor progress)
					throws CoreException {
				IProject[] missing = getMissingProjects(target, ProjectUtil
						.getValidOpenProjects(repository));

				progress.setTaskName(NLS.bind(
						CoreText.BranchOperation_performingBranch, target));
				progress.setWorkRemaining(missing.length > 0 ? 4 : 3);

				if (missing.length > 0) {
					SubMonitor closeMonitor = progress.newChild(1);
					closeMonitor.setWorkRemaining(missing.length);
					for (IProject project : missing) {
						closeMonitor.subTask(MessageFormat.format(
								CoreText.BranchOperation_closingMissingProject,
								project.getName()));
						project.close(closeMonitor.newChild(1));
					}
				}
			}

			private void refreshAffectedProjects(SubMonitor progress)
					throws CoreException {
				List<String> pathsToHandle = new ArrayList<String>();
				pathsToHandle.addAll(result.getModifiedList());
				pathsToHandle.addAll(result.getRemovedList());
				pathsToHandle.addAll(result.getConflictList());
				IProject[] refreshProjects = ProjectUtil
						.getProjectsContaining(repository, pathsToHandle);
				ProjectUtil.refreshValidProjects(refreshProjects, delete,
						progress.newChild(1));
			}
		};
		// lock workspace to protect working tree changes
		ResourcesPlugin.getWorkspace().run(action, getSchedulingRule(),
				IWorkspace.AVOID_UPDATE, m);
	}

