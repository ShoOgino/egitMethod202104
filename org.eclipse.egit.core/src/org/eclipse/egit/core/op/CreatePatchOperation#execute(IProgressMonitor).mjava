	public void execute(IProgressMonitor monitor) throws CoreException {
		EclipseGitProgressTransformer gitMonitor;
		if (monitor == null)
			gitMonitor = new EclipseGitProgressTransformer(
					new NullProgressMonitor());
		else
			gitMonitor = new EclipseGitProgressTransformer(monitor);

		final StringBuilder sb = new StringBuilder();
		final DiffFormatter diffFmt = new DiffFormatter(
				new ByteArrayOutputStream() {

					@Override
					public synchronized void write(byte[] b, int off, int len) {
						super.write(b, off, len);
						if (currentEncoding == null)
							sb.append(toString());
						else try {
							sb.append(toString(currentEncoding));
						} catch (UnsupportedEncodingException e) {
							sb.append(toString());
						}
						reset();
					}
				});

		diffFmt.setProgressMonitor(gitMonitor);
		diffFmt.setContext(contextLines);

		RevCommit[] parents = commit.getParents();
		if (parents.length > 1)
			throw new IllegalStateException(
					"Cannot create patch for merge commit"); //$NON-NLS-1$

		if (parents.length == 0)
			throw new IllegalStateException(
					"Cannot create patch for first commit"); //$NON-NLS-1$

		if (useGitFormat)
			writeGitPatchHeader(sb);

		try {
			diffFmt.setRepository(repository);
			List<DiffEntry> diffs = diffFmt.scan(parents[0].getId(), commit.getId());
			for (DiffEntry ent : diffs) {
				String path;
				if (ChangeType.DELETE.equals(ent.getChangeType()))
					path = ent.getOldPath();
				else
					path = ent.getNewPath();
				currentEncoding = CompareCoreUtils.getResourceEncoding(repository, path);
				diffFmt.format(ent);
			}
		} catch (IOException e) {
			Activator.logError("Patch file could not be written", e); //$NON-NLS-1$
		}

		patchContent = sb.toString();
		// trim newline
		if (patchContent.endsWith("\n")) //$NON-NLS-1$
			patchContent = patchContent.substring(0, patchContent.length() - 1);
	}

