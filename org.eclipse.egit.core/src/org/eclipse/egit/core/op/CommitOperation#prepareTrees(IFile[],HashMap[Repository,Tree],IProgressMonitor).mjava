	private boolean prepareTrees(IFile[] selectedItems,
			HashMap<Repository, Tree> treeMap, IProgressMonitor monitor)
			throws IOException, UnsupportedEncodingException {
		if (selectedItems.length == 0) {
			// amending commit - need to put something into the map
			for (Repository repo : repos) {
				treeMap.put(repo, mapTree(repo, Constants.HEAD));
			}
		}

		for (IFile file : selectedItems) {

			if (monitor.isCanceled())
				return false;
			monitor.worked(1);

			IProject project = file.getProject();
			RepositoryMapping repositoryMapping = RepositoryMapping
					.getMapping(project);
			Repository repository = repositoryMapping.getRepository();
			Tree projTree = treeMap.get(repository);
			if (projTree == null) {
				projTree = mapTree(repository, Constants.HEAD);
				if (projTree == null)
					projTree = new Tree(repository);
				treeMap.put(repository, projTree);
				// TODO is this the right Location?
				if (GitTraceLocation.CORE.isActive())
					GitTraceLocation.getTrace().trace(
							GitTraceLocation.CORE.getLocation(),
							"Orig tree id: " + projTree.getId()); //$NON-NLS-1$
			}
			GitIndex index = repository.getIndex();
			String repoRelativePath = repositoryMapping
					.getRepoRelativePath(file);
			String string = repoRelativePath;

			TreeEntry treeMember = projTree.findBlobMember(repoRelativePath);
			// we always want to delete it from the current tree, since if it's
			// updated, we'll add it again
			Tree treeWithDeletedEntry = null;
			if (treeMember != null) {
				treeWithDeletedEntry = treeMember.getParent();
				treeMember.delete();
			}

			Entry idxEntry = index.getEntry(string);
			if (notIndexed.contains(file)) {
				File thisfile = new File(repositoryMapping.getWorkTree(),
						string);
				if (!thisfile.isFile()) {
					index.remove(repositoryMapping.getWorkTree(), thisfile);
					// TODO is this the right Location?
					if (GitTraceLocation.CORE.isActive())
						GitTraceLocation.getTrace().trace(
								GitTraceLocation.CORE.getLocation(),
								"Phantom file, so removing from index"); //$NON-NLS-1$
					while (treeWithDeletedEntry != null && treeWithDeletedEntry.memberCount() == 0) {
						Tree toDelete = treeWithDeletedEntry;
						treeWithDeletedEntry = treeWithDeletedEntry.getParent();
						toDelete.delete();
					}
					continue;
				} else {
					idxEntry.update(thisfile);
				}
			}
			if (notTracked.contains(file)) {
				idxEntry = index.add(repositoryMapping.getWorkTree(), new File(
						repositoryMapping.getWorkTree(), repoRelativePath));

			}

			if (idxEntry != null) {
				projTree.addFile(repoRelativePath);
				TreeEntry newMember = projTree.findBlobMember(repoRelativePath);

				newMember.setId(idxEntry.getObjectId());
				if (newMember instanceof FileTreeEntry)
					((FileTreeEntry) newMember).setExecutable(
							(idxEntry.getModeBits() &
									FileMode.EXECUTABLE_FILE.getBits())
							== FileMode.EXECUTABLE_FILE.getBits());

				// TODO is this the right Location?
				if (GitTraceLocation.CORE.isActive())
					GitTraceLocation.getTrace().trace(
							GitTraceLocation.CORE.getLocation(),
							"New member id for " + repoRelativePath //$NON-NLS-1$
									+ ": " + newMember.getId() + " idx id: " //$NON-NLS-1$ //$NON-NLS-2$
									+ idxEntry.getObjectId());
			}
		}
		return true;
	}

