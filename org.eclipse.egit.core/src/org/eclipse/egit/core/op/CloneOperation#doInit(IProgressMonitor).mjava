	private void doInit(final IProgressMonitor monitor)
			throws URISyntaxException, IOException {
		monitor.setTaskName(CoreText.CloneOperation_initializingRepository);

		local = new FileRepository(gitdir);
		local.create();

		if (refName != null && refName.startsWith(Constants.R_HEADS)) {
			final RefUpdate head = local.updateRef(Constants.HEAD);
			head.disableRefLog();
			head.link(refName);
		}

		FileBasedConfig config = local.getConfig();
		remoteConfig = new RemoteConfig(config, remoteName);
		remoteConfig.addURI(uri);

		final String dst = Constants.R_REMOTES + remoteConfig.getName();
		RefSpec wcrs = new RefSpec();
		wcrs = wcrs.setForceUpdate(true);
		wcrs = wcrs.setSourceDestination(Constants.R_HEADS
				+ "*", dst + "/*"); //$NON-NLS-1$ //$NON-NLS-2$

		if (allSelected) {
			remoteConfig.addFetchRefSpec(wcrs);
		} else {
			for (final Ref selectedRef : selectedBranches)
				if (wcrs.matchSource(selectedRef))
					remoteConfig.addFetchRefSpec(wcrs.expandFromSource(selectedRef));
		}

		// we're setting up for a clone with a checkout
		config.setBoolean(
				ConfigConstants.CONFIG_CORE_SECTION, null, ConfigConstants.CONFIG_KEY_BARE, false);

		remoteConfig.update(config);

		// branch is like 'Constants.R_HEADS + branchName', we need only
		// the 'branchName' part
		if (refName != null && refName.startsWith(Constants.R_HEADS)) {
			String branchName = Repository.shortenRefName(refName);

			// setup the default remote branch for branchName
			config.setString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_REMOTE, remoteName);
			config.setString(ConfigConstants.CONFIG_BRANCH_SECTION, branchName, ConfigConstants.CONFIG_KEY_MERGE, refName);
		}
		config.save();
	}

