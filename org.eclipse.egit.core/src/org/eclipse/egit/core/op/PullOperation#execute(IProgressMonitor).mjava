	@Override
	public void execute(IProgressMonitor m) throws CoreException {
		if (!results.isEmpty())
			throw new CoreException(new Status(IStatus.ERROR, Activator
					.getPluginId(), CoreText.OperationAlreadyExecuted));
		SubMonitor progress = SubMonitor.convert(m,
				NLS.bind(CoreText.PullOperation_TaskName,
						Integer.valueOf(repositories.length)),
				1);
		IWorkspaceRunnable action = new IWorkspaceRunnable() {
			@Override
			public void run(IProgressMonitor mymonitor) throws CoreException {
				if (mymonitor.isCanceled())
					throw new CoreException(Status.CANCEL_STATUS);
				SubMonitor progress = SubMonitor.convert(mymonitor,
						repositories.length * 2);
				for (int i = 0; i < repositories.length; i++) {
					Repository repository = repositories[i];
					IProject[] validProjects = ProjectUtil.getValidOpenProjects(repository);
					PullCommand pull = new Git(repository).pull();
					PullResult pullResult = null;
					try {
						pull.setProgressMonitor(new EclipseGitProgressTransformer(
										progress.newChild(1)));
						pull.setTimeout(timeout);
						pull.setCredentialsProvider(credentialsProvider);
						MergeStrategy strategy = Activator.getDefault()
								.getPreferredMergeStrategy();
						if (strategy != null) {
							pull.setStrategy(strategy);
						}
						pullResult = pull.call();
						results.put(repository, pullResult);
					} catch (DetachedHeadException e) {
						results.put(repository, Activator.error(
								CoreText.PullOperation_DetachedHeadMessage, e));
					} catch (InvalidConfigurationException e) {
						IStatus error = Activator
								.error(CoreText.PullOperation_PullNotConfiguredMessage,
										e);
						results.put(repository, error);
					} catch (GitAPIException e) {
						results.put(repository,
								Activator.error(e.getMessage(), e));
					} catch (JGitInternalException e) {
						Throwable cause = e.getCause();
						if (cause == null || !(cause instanceof TransportException))
							cause = e;
						results.put(repository,
								Activator.error(cause.getMessage(), cause));
					} finally {
						progress.worked(1);
						if (refreshNeeded(pullResult)) {
							progress.setWorkRemaining(2);
							ProjectUtil.refreshValidProjects(validProjects,
									progress.newChild(1));
							progress.worked(1);
						}
					}
				}
			}
		};
		// lock workspace to protect working tree changes
		ResourcesPlugin.getWorkspace().run(action, getSchedulingRule(),
				IWorkspace.AVOID_UPDATE, progress);
	}

