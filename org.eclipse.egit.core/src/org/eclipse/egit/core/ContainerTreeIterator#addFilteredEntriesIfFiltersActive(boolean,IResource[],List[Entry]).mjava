	/**
	 * Add entries for filtered resources.
	 *
	 * @param hasInheritedResourceFilters
	 *            true if resource filters of parents could be active, false
	 *            otherwise
	 * @param memberResources
	 *            the resources returned from members() that do not have to be
	 *            added as entries again
	 * @param entries
	 *            where entries should be added to
	 * @return true if we now have resource filters that are inherited, false if
	 *         there are no resource filters which are inherited.
	 */
	private boolean addFilteredEntriesIfFiltersActive(
			final boolean hasInheritedResourceFilters,
			final IResource[] memberResources, final List<Entry> entries) {
		// Inheritable resource filters must be propagated.
		boolean inheritableResourceFilter = hasInheritedResourceFilters;
		IResourceFilterDescription[] filters;
		try {
			filters = node.getFilters();
		} catch (CoreException e) {
			// Should not happen, but assume we have no filters then.
			filters = new IResourceFilterDescription[] {};
		}

		if (filters.length != 0 || hasInheritedResourceFilters) {
			if (!inheritableResourceFilter) {
				for (IResourceFilterDescription filter : filters) {
					boolean inheritable = (filter.getType() & IResourceFilterDescription.INHERITABLE) != 0;
					if (inheritable)
						inheritableResourceFilter = true;
				}
			}

			Set<File> resourceEntries = new HashSet<File>();
			for (IResource resource : memberResources)
				// Make sure linked resources are ignored here.
				// This is particularly important in the case of a linked
				// resource which targets a normally filtered/hidden file
				// within the same location. In such case, ignoring it here
				// ensures the actual target gets included in the code below.
				if (!resource.isLinked()) {
					IPath location = resource.getLocation();
					if (location != null)
						resourceEntries.add(location.toFile());
				}

			addFilteredEntries(resourceEntries, entries);
		}
		return inheritableResourceFilter;
	}

