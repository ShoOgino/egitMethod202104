	public DecoratableResourceAdapter(@NonNull IndexDiffData indexDiffData,
			@NonNull IResource resourceToWrap)
			throws IOException {
		super(resourceToWrap);
		boolean trace = GitTraceLocation.DECORATION.isActive();
		long start = 0;
		if (trace) {
			GitTraceLocation.getTrace().trace(
					GitTraceLocation.DECORATION.getLocation(),
					"Decorate " + resource.getFullPath()); //$NON-NLS-1$
			start = System.currentTimeMillis();
		}
		try {
			RepositoryMapping mapping = RepositoryMapping
					.getMapping(resourceToWrap);
			if (mapping == null) {
				return;
			}
			Repository repository = mapping.getRepository();
			if (repository == null) {
				return;
			}
			IResourceState baseState = ResourceStateFactory.getInstance()
					.get(indexDiffData, resourceToWrap);
			setTracked(baseState.isTracked());
			setIgnored(baseState.isIgnored());
			setDirty(baseState.isDirty());
			setConflicts(baseState.hasConflicts());
			setAssumeUnchanged(baseState.isAssumeUnchanged());
			setStagingState(baseState.getStagingState());
			if (resource.getType() == IResource.PROJECT
					|| resource.equals(mapping.getContainer())) {
				// We only need this very expensive info for project decoration,
				// and for decorating folders that are submodule roots.
				repositoryName = DecoratableResourceHelper
						.getRepositoryName(repository);
				branch = DecoratableResourceHelper.getShortBranch(repository);
				branchStatus = DecoratableResourceHelper.getBranchStatus(repository);
				RevCommit headCommit = DecoratableResourceHelper
						.getHeadCommit(repository);
				if (headCommit != null) {
					commitMessage = headCommit.getShortMessage();
				}
			}
		} finally {
			if (trace)
				GitTraceLocation
						.getTrace()
						.trace(GitTraceLocation.DECORATION.getLocation(),
								"Decoration took " + (System.currentTimeMillis() - start) //$NON-NLS-1$
										+ " ms"); //$NON-NLS-1$
		}
	}

