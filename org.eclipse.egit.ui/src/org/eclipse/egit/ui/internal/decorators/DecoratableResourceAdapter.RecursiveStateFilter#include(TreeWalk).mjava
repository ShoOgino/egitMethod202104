		@Override
		public boolean include(TreeWalk treeWalk)
				throws MissingObjectException, IncorrectObjectTypeException,
				IOException {

			final WorkingTreeIterator workingTreeIterator = treeWalk.getTree(
					T_WORKSPACE, WorkingTreeIterator.class);
			if (workingTreeIterator != null) {
				if (workingTreeIterator instanceof ContainerTreeIterator) {
					final ContainerTreeIterator workspaceIterator =
						(ContainerTreeIterator) workingTreeIterator;
					ResourceEntry resourceEntry = workspaceIterator
							.getResourceEntry();
					if (resource.equals(resourceEntry.getResource())
							&& workspaceIterator.isEntryIgnored()) {
						ignored = true;
						return false;
					}
				} else {
					// For the project resource, it's still the
					// AdaptableFileTreeIterator. So we have to compare the path
					// of the resource with path of the iterator
					IPath wdPath = new Path(repository.getWorkTree()
							.getAbsolutePath()).append(workingTreeIterator
							.getEntryPathString());
					IPath resPath = resource.getLocation();
					if (wdPath.equals(resPath)
							&& workingTreeIterator.isEntryIgnored()) {
						ignored = true;
						return false;
					}
				}
			}
			// Note: for obtaining the ignored info we have to go through the
			// whole working tree and can no longer cut here if the current
			// entry is not contained in the index and not contained in head

			if (FileMode.TREE.equals(treeWalk.getRawMode(T_WORKSPACE)))
				return shouldRecurse(treeWalk);

			// Backup current state so far
			Staged wasStaged = staged;
			boolean wasDirty = dirty;
			boolean hadConflicts = conflicts;

			extractResourceProperties(treeWalk);
			filesChecked++;

			// Merge results with old state
			ignored = false;
			assumeValid = false;
			dirty = wasDirty || dirty;
			conflicts = hadConflicts || conflicts;
			if (staged != wasStaged && filesChecked > 1)
				staged = Staged.MODIFIED;

			return false;
		}

