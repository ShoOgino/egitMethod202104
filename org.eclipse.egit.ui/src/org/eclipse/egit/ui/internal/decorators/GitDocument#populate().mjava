	void populate() throws IOException {
		if (GitTraceLocation.QUICKDIFF.isActive())
			GitTraceLocation.getTrace().trace(
					GitTraceLocation.QUICKDIFF.getLocation(),"(GitDocument) populate: " + resource); //$NON-NLS-1$
		RepositoryMapping mapping = RepositoryMapping.getMapping(resource);
		if (mapping == null) {
			setResolved(null, null, null, ""); //$NON-NLS-1$
			return;
		}
		final String gitPath = mapping.getRepoRelativePath(resource);
		final Repository repository = mapping.getRepository();
		String baseline = GitQuickDiffProvider.baseline.get(repository);
		if (baseline == null)
			baseline = Constants.HEAD;
		ObjectId commitId = repository.resolve(baseline);
		if (commitId != null) {
			if (commitId.equals(lastCommit)) {
				if (GitTraceLocation.QUICKDIFF.isActive())
					GitTraceLocation.getTrace().trace(
							GitTraceLocation.QUICKDIFF.getLocation(),
							"(GitDocument) already resolved"); //$NON-NLS-1$
				return;
			}
		} else {
			String msg = NLS.bind(UIText.GitDocument_errorResolveQuickdiff,
					new Object[] { baseline, resource, repository });
			Activator.logError(msg, new Throwable());
			setResolved(null, null, null, ""); //$NON-NLS-1$
			return;
		}
		RevWalk rw = new RevWalk(repository);
		RevCommit baselineCommit;
		try {
			baselineCommit = rw.parseCommit(commitId);
		} catch (IOException err) {
			String msg = NLS.bind(UIText.GitDocument_errorLoadCommit,
					new Object[] { commitId, baseline, resource, repository });
			Activator.logError(msg, err);
			setResolved(null, null, null, ""); //$NON-NLS-1$
			return;
		} finally {
			rw.release();
		}
		RevTree treeId = baselineCommit.getTree();
		if (treeId.equals(lastTree)) {
			if (GitTraceLocation.QUICKDIFF.isActive())
				GitTraceLocation.getTrace().trace(
						GitTraceLocation.QUICKDIFF.getLocation(),
						"(GitDocument) already resolved"); //$NON-NLS-1$
			return;
		}
		Tree baselineTree = repository.mapTree(treeId);
		if (baselineTree == null) {
			String msg = NLS.bind(UIText.GitDocument_errorLoadTree,
					new Object[] { treeId, baseline, resource, repository });
			Activator.logError(msg, new Throwable());
			setResolved(null, null, null, ""); //$NON-NLS-1$
			return;
		}
		TreeEntry blobEntry = baselineTree.findBlobMember(gitPath);
		if (blobEntry != null && !blobEntry.getId().equals(lastBlob)) {
			if (GitTraceLocation.QUICKDIFF.isActive())
				GitTraceLocation.getTrace().trace(
						GitTraceLocation.QUICKDIFF.getLocation(),
						"(GitDocument) compareTo: " + baseline); //$NON-NLS-1$
			ObjectLoader loader = repository.open(blobEntry.getId(),
					Constants.OBJ_BLOB);
			byte[] bytes = loader.getBytes();
			String charset;
			// Get the encoding for the current version. As a matter of
			// principle one might want to use the eclipse settings for the
			// version we are retrieving as that may be defined by the
			// project settings, but there is no historic API for this.
			IEncodedStorage encodedStorage = ((IEncodedStorage)resource);
			try {
				charset = encodedStorage.getCharset();
				if (charset != null)
					charset = resource.getParent().getDefaultCharset();
			} catch (CoreException e) {
				charset = Constants.CHARACTER_ENCODING;
			}
			// Finally we could consider validating the content with respect
			// to the content. We don't do that here.
			String s = new String(bytes, charset);
			setResolved(commitId, baselineTree.getId(), blobEntry.getId(), s);
			if (GitTraceLocation.QUICKDIFF.isActive())
				GitTraceLocation
						.getTrace()
						.trace(
								GitTraceLocation.QUICKDIFF.getLocation(),
								"(GitDocument) has reference doc, size=" + s.length() + " bytes"); //$NON-NLS-1$ //$NON-NLS-2$
		} else {
			if (blobEntry == null)
				setResolved(null, null, null, ""); //$NON-NLS-1$
			else
			if (GitTraceLocation.QUICKDIFF.isActive())
				GitTraceLocation.getTrace().trace(
						GitTraceLocation.QUICKDIFF.getLocation(),
						"(GitDocument) already resolved"); //$NON-NLS-1$
		}
	}

