	void populate() throws IOException {
		Activator.trace("(GitDocument) populate: " + resource); //$NON-NLS-1$
		RepositoryMapping mapping = RepositoryMapping.getMapping(resource);
		if (mapping == null) {
			setResolved(null, null, null, ""); //$NON-NLS-1$
			return;
		}
		final String gitPath = mapping.getRepoRelativePath(resource);
		final Repository repository = mapping.getRepository();
		String baseline = GitQuickDiffProvider.baseline.get(repository);
		if (baseline == null)
			baseline = Constants.HEAD;
		ObjectId commitId = repository.resolve(baseline);
		if (commitId != null) {
			if (commitId.equals(lastCommit)) {
				Activator.trace("(GitDocument) already resolved"); //$NON-NLS-1$
				return;
			}
		} else {
			Activator.logError("Could not resolve quickdiff baseline "
					+ baseline + " corresponding to " + resource + " in "
					+ repository, new Throwable());
			setResolved(null, null, null, ""); //$NON-NLS-1$
			return;
		}
		Commit baselineCommit = repository.mapCommit(commitId);
		if (baselineCommit == null) {
			Activator.logError("Could not load commit " + commitId + " for "
					+ baseline + " corresponding to " + resource + " in "
					+ repository, new Throwable());
			setResolved(null, null, null, ""); //$NON-NLS-1$
			return;
		}
		ObjectId treeId = baselineCommit.getTreeId();
		if (treeId.equals(lastTree)) {
			Activator.trace("(GitDocument) already resolved"); //$NON-NLS-1$
			return;
		}
		Tree baselineTree = baselineCommit.getTree();
		if (baselineTree == null) {
			Activator.logError("Could not load tree " + treeId + " for "
					+ baseline + " corresponding to " + resource + " in "
					+ repository, new Throwable());
			setResolved(null, null, null, ""); //$NON-NLS-1$
			return;
		}
		TreeEntry blobEntry = baselineTree.findBlobMember(gitPath);
		if (blobEntry != null && !blobEntry.getId().equals(lastBlob)) {
			Activator.trace("(GitDocument) compareTo: " + baseline); //$NON-NLS-1$
			ObjectLoader loader = repository.openBlob(blobEntry.getId());
			byte[] bytes = loader.getBytes();
			String charset;
			// Get the encoding for the current version. As a matter of
			// principle one might want to use the eclipse settings for the
			// version we are retrieving as that may be defined by the
			// project settings, but there is no historic API for this.
			IEncodedStorage encodedStorage = ((IEncodedStorage)resource);
			try {
				if (encodedStorage != null)
					charset = encodedStorage.getCharset();
				else
					charset = resource.getParent().getDefaultCharset();
			} catch (CoreException e) {
				charset = Constants.CHARACTER_ENCODING;
			}
			// Finally we could consider validating the content with respect
			// to the content. We don't do that here.
			String s = new String(bytes, charset);
			setResolved(commitId, baselineTree.getId(), blobEntry.getId(), s);
			Activator.trace("(GitDocument) has reference doc, size=" + s.length() + " bytes"); //$NON-NLS-1$ //$NON-NLS-2$
		} else {
			if (blobEntry == null)
				setResolved(null, null, null, ""); //$NON-NLS-1$
			else
				Activator.trace("(GitDocument) already resolved"); //$NON-NLS-1$
		}
	}

