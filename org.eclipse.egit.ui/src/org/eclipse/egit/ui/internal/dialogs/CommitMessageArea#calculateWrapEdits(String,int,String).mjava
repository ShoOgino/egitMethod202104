	/**
	 * Calculate a list of {@link WrapEdit} which can be applied to the text to
	 * get a new text that is wrapped at word boundaries. Existing line breaks
	 * are left alone (text is not reflowed).
	 *
	 * @param text
	 *            the text to calculate the wrap edits for
	 * @param maxLineLength
	 *            the maximum line length
	 * @param lineDelimiter
	 *            line delimiter used in text and for wrapping
	 * @return a list of {@link WrapEdit} objects which specify how the text
	 *         should be edited to obtain the wrapped text. Offsets of later
	 *         edits are already adjusted for the fact that wrapping a line may
	 *         shift the text backwards. So the list can just be iterated and
	 *         each edit applied in order.
	 */
	public static List<WrapEdit> calculateWrapEdits(final String text, final int maxLineLength, final String lineDelimiter) {
		List<WrapEdit> wrapEdits = new LinkedList<WrapEdit>();

		int offset = 0;
		int lineDelimiterLength = lineDelimiter.length();

		String[] chunks = text.split(lineDelimiter, -1);
		for (int chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {
			String chunk = chunks[chunkIndex];

			String[] words = chunk.split(" ", -1); //$NON-NLS-1$
			int lineLength = 0;

			for (int wordIndex = 0; wordIndex < words.length; wordIndex++) {
				String word = words[wordIndex];

				int wordLength = word.length();
				int newLineLength = lineLength + wordLength + 1 /* the space */;
				if (newLineLength > maxLineLength) {
					/* don't break before a single long word */
					if (lineLength != 0) {
						wrapEdits.add(new WrapEdit(offset, 1));
						/* adjust for the shifting of text after the edit is applied */
						offset += lineDelimiterLength;
					}
					lineLength = 0;
				} else if (wordIndex != 0) {
					lineLength += 1;
					offset += 1;
				}
				offset += wordLength;
				lineLength += wordLength;
			}

			if (chunkIndex != chunks.length - 1) {
				offset += lineDelimiterLength;
			}
		}

		return wrapEdits;
	}

