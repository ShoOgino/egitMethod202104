	/**
	 * @param paths
	 * @return the calculated commit message
	 */
	String calculateCommitMessage(Collection<String> paths) {
		if (commitMessage != null) {
			// special case for merge
			return commitMessage;
		}

		if (amending)
			return previousCommitMessage;
		StringBuilder calculatedCommitMessage = new StringBuilder();

		Set<IResource> resources = new HashSet<>();
		for (String path : paths) {
			IFile file = findFile(path);
			if (file != null)
				resources.add(file.getProject());
		}
		if (resources.size() == 0 && repository != null) {
			resources
					.addAll(Arrays.asList(ProjectUtil.getProjects(repository)));
		}
		List<ICommitMessageProvider> messageProviders = getCommitMessageProviders();
		IResource[] resourcesArray = resources.toArray(new IResource[0]);
		String providedMessageSeparator = "\n\n"; //$NON-NLS-1$

		for (ICommitMessageProvider messageProvider : messageProviders) {
			String message = null;
			try {
				message = messageProvider.getMessage(resourcesArray);
			} catch (RuntimeException e) {
				Activator.logError(e.getMessage(), e);
			}

			if (message != null && !message.trim().isEmpty()) {
				if (calculatedCommitMessage.length() > 0) {
					calculatedCommitMessage.append(providedMessageSeparator);
				}
				calculatedCommitMessage.append((message.trim()));
			}
		}

		return calculatedCommitMessage.toString();
	}

