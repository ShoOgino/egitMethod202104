	/**
	 * Calculate a list of {@link WrapEdit} which can be applied to the text to
	 * get a new text that is wrapped at word boundaries. Existing line breaks
	 * are left alone (text is not reflowed).
	 *
	 * @param text
	 *            the text to calculate the wrap edits for
	 * @param maxLineLength
	 *            the maximum line length
	 * @param lineDelimiter
	 *            line delimiter used in text and for wrapping
	 * @return a list of {@link WrapEdit} objects which specify how the text
	 *         should be edited to obtain the wrapped text. Offsets of later
	 *         edits are already adjusted for the fact that wrapping a line may
	 *         shift the text backwards. So the list can just be iterated and
	 *         each edit applied in order.
	 */
	public static List<WrapEdit> calculateWrapEdits(final String text, final int maxLineLength, final String lineDelimiter) {
		List<WrapEdit> wrapEdits = new LinkedList<WrapEdit>();

		final int lineDelimiterLength = lineDelimiter.length();
		final int spaceLength = 1;

		int offset = 0;
		boolean lastChunkWasWrapped = false;
		int lastChunkWrappedOffset = 0;

		String[] chunks = text.split(lineDelimiter, -1);
		for (int chunkIndex = 0; chunkIndex < chunks.length; chunkIndex++) {
			String chunk = chunks[chunkIndex];

			String[] words = chunk.split(" ", -1); //$NON-NLS-1$
			int lineLength = 0;

			for (int wordIndex = 0; wordIndex < words.length; wordIndex++) {
				String word = words[wordIndex];
				int wordLength = word.length();
				boolean adjustForSpace = wordIndex != 0;

				if (wordIndex == 0 && lastChunkWasWrapped) {
					if (wordLength != 0 && !STARTS_WITH_SYMBOL.matcher(word).matches()) {
						wrapEdits.add(new WrapEdit(offset - lineDelimiterLength, lineDelimiterLength, " ")); //$NON-NLS-1$
						/* adjust for join edit above */
						offset -= lineDelimiterLength;
						adjustForSpace = true;
						lineLength = offset - lastChunkWrappedOffset;
					}
					lastChunkWasWrapped = false;
				}

				int newLineLength = lineLength + spaceLength + wordLength;
				if (newLineLength > maxLineLength) {
					/* don't break before a single long word */
					if (lineLength != 0) {
						wrapEdits.add(new WrapEdit(offset, spaceLength, lineDelimiter));
						/* adjust for the shifting of text after the edit is applied */
						offset += lineDelimiterLength;
						adjustForSpace = false;
						lastChunkWasWrapped = true;
						lastChunkWrappedOffset = offset;
					}
					lineLength = 0;
				}

				if (adjustForSpace) {
					offset += spaceLength;
					lineLength += spaceLength;
				}

				offset += wordLength;
				lineLength += wordLength;
			}

			offset += lineDelimiterLength;
		}

		return wrapEdits;
	}

