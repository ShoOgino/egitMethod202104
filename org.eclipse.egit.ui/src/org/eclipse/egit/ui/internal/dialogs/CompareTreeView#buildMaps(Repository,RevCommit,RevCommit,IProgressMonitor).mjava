	private void buildMaps(Repository repository, RevCommit leftCommit,
			RevCommit rightCommit, IProgressMonitor monitor)
			throws InterruptedException, IOException {
		monitor.beginTask(UIText.CompareTreeView_AnalyzingRepositoryTaskText,
				IProgressMonitor.UNKNOWN);
		boolean useIndex = rightVersion.equals(INDEX_VERSION);
		rightOnly.clear();
		equalIds.clear();
		leftVersionMap.clear();
		rightVersionMap.clear();
		rightPathsWithChildren.clear();
		leftOnly.clear();
		leftPathsWithChildren.clear();
		boolean checkIgnored = false;
		TreeWalk tw = new TreeWalk(repository);
		try {
			int leftTreeIndex;
			if (leftCommit == null) {
				checkIgnored = true;
				leftTreeIndex = tw.addTree(new AdaptableFileTreeIterator(
						repository, ResourcesPlugin.getWorkspace().getRoot()));
			} else
				leftTreeIndex = tw.addTree(new CanonicalTreeParser(null,
						repository.newObjectReader(), leftCommit.getTree()));
			int rightTreeIndex;
			if (!useIndex)
				rightTreeIndex = tw.addTree(new CanonicalTreeParser(null,
						repository.newObjectReader(), rightCommit.getTree()));
			else
				rightTreeIndex = tw.addTree(new DirCacheIterator(repository
						.readDirCache()));

			if (input instanceof IResource[]) {
				IResource[] resources = (IResource[]) input;
				List<TreeFilter> orFilters = new ArrayList<TreeFilter>(
						resources.length);

				for (IResource resource : resources) {
					String relPath = repositoryMapping
							.getRepoRelativePath(resource);
					if (relPath.length() > 0)
						orFilters.add(PathFilter.create(relPath));
				}
				if (orFilters.size() > 1)
					tw.setFilter(OrTreeFilter.create(orFilters));
				else if (orFilters.size() == 1)
					tw.setFilter(orFilters.get(0));
			}

			tw.setRecursive(true);

			if (monitor.isCanceled())
				throw new InterruptedException();
			while (tw.next()) {
				if (monitor.isCanceled())
					throw new InterruptedException();
				AbstractTreeIterator rightVersionIterator = tw.getTree(
						rightTreeIndex, AbstractTreeIterator.class);
				AbstractTreeIterator leftVersionIterator = tw.getTree(
						leftTreeIndex, AbstractTreeIterator.class);
				if (checkIgnored
						&& leftVersionIterator != null
						&& ((WorkingTreeIterator) leftVersionIterator)
								.isEntryIgnored())
					continue;
				if (rightVersionIterator != null && leftVersionIterator != null) {
					monitor.setTaskName(leftVersionIterator
							.getEntryPathString());
					IPath currentPath = new Path(leftVersionIterator
							.getEntryPathString());
					if (!useIndex)
						rightVersionMap.put(currentPath, GitFileRevision
								.inCommit(repository, rightCommit,
										leftVersionIterator
												.getEntryPathString(), tw
												.getObjectId(rightTreeIndex)));
					else
						rightVersionMap.put(currentPath, GitFileRevision
								.inIndex(repository, leftVersionIterator
										.getEntryPathString()));
					if (leftCommit != null)
						leftVersionMap.put(currentPath, GitFileRevision
								.inCommit(repository, leftCommit,
										leftVersionIterator
												.getEntryPathString(), tw
												.getObjectId(leftTreeIndex)));
					boolean equalContent = rightVersionIterator
							.getEntryObjectId().equals(
									leftVersionIterator.getEntryObjectId());
					if (equalContent)
						equalIds.add(currentPath);

					if (equalContent && !showEquals)
						continue;

					while (currentPath.segmentCount() > 0) {
						currentPath = currentPath.removeLastSegments(1);
						boolean addedLeft = showAddedOnly
								|| !leftPathsWithChildren.add(currentPath);
						boolean addedRight = showDeletedOnly
								|| !rightPathsWithChildren.add(currentPath);
						if (addedLeft && addedRight)
							break;
					}

				} else if (leftVersionIterator != null
						&& rightVersionIterator == null) {
					monitor.setTaskName(leftVersionIterator
							.getEntryPathString());
					// only on left side
					IPath currentPath = new Path(leftVersionIterator
							.getEntryPathString());
					leftOnly.add(currentPath);
					if (leftCommit != null)
						leftVersionMap.put(currentPath, GitFileRevision
								.inCommit(repository, leftCommit,
										leftVersionIterator
												.getEntryPathString(), tw
												.getObjectId(leftTreeIndex)));
					while (currentPath.segmentCount() > 0) {
						currentPath = currentPath.removeLastSegments(1);
						if (!leftPathsWithChildren.add(currentPath))
							break;
					}

				} else if (rightVersionIterator != null
						&& leftVersionIterator == null) {
					monitor.setTaskName(rightVersionIterator
							.getEntryPathString());
					// only on right side
					IPath currentPath = new Path(rightVersionIterator
							.getEntryPathString());
					rightOnly.add(currentPath);

					if (!useIndex)
						rightVersionMap.put(currentPath, GitFileRevision
								.inCommit(repository, rightCommit,
										rightVersionIterator
												.getEntryPathString(), tw
												.getObjectId(rightTreeIndex)));
					else
						rightVersionMap.put(currentPath, GitFileRevision
								.inIndex(repository, rightVersionIterator
										.getEntryPathString()));

					while (currentPath.segmentCount() > 0) {
						currentPath = currentPath.removeLastSegments(1);
						if (!rightPathsWithChildren.add(currentPath))
							break;
					}
				}
			}
		} finally {
			tw.release();
			monitor.done();
		}
	}

