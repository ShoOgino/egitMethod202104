	private void buildMaps(Repository repository, RevCommit baseCommit,
			RevCommit compareCommit, IProgressMonitor monitor)
			throws InterruptedException, IOException {
		monitor.beginTask(UIText.CompareTreeView_AnalyzingRepositoryTaskText,
				IProgressMonitor.UNKNOWN);
		long previousTimeMilliseconds = System.currentTimeMillis();
		boolean useIndex = compareVersion.equals(INDEX_VERSION);
		fileNodes.clear();
		containerNodes.clear();
		boolean checkIgnored = false;
		try (TreeWalk tw = new TreeWalk(repository)) {
			int baseTreeIndex;
			if (baseCommit == null) {
				checkIgnored = true;
				baseTreeIndex = tw.addTree(new FileTreeIterator(repository));
			} else
				baseTreeIndex = tw.addTree(new CanonicalTreeParser(null,
						repository.newObjectReader(), baseCommit.getTree()));
			int compareTreeIndex;
			if (!useIndex)
				compareTreeIndex = tw.addTree(new CanonicalTreeParser(null,
						repository.newObjectReader(), compareCommit.getTree()));
			else
				compareTreeIndex = tw.addTree(new DirCacheIterator(repository
						.readDirCache()));

			if (input instanceof IResource[]) {
				IResource[] resources = (IResource[]) input;
				List<TreeFilter> orFilters = new ArrayList<>(
						resources.length);

				for (IResource resource : resources) {
					String relPath = repositoryMapping
							.getRepoRelativePath(resource);
					if (relPath != null && relPath.length() > 0) {
						orFilters.add(PathFilter.create(relPath));
					}
				}
				if (checkIgnored) {
					if (orFilters.size() > 1) {
						TreeFilter andFilter = AndTreeFilter.create(new NotIgnoredFilter(baseTreeIndex),
								OrTreeFilter.create(orFilters));
						tw.setFilter(andFilter);
					} else if (orFilters.size() == 1) {
						TreeFilter andFilter = AndTreeFilter.create(new NotIgnoredFilter(baseTreeIndex),
								orFilters.get(0));
						tw.setFilter(andFilter);
					} else
						tw.setFilter(new NotIgnoredFilter(baseTreeIndex));

				} else if (orFilters.size() > 1)
					tw.setFilter(OrTreeFilter.create(orFilters));
				else if (orFilters.size() == 1)
					tw.setFilter(orFilters.get(0));
			}

			tw.setRecursive(true);

			if (monitor.isCanceled())
				throw new InterruptedException();
			while (tw.next()) {
				if (monitor.isCanceled())
					throw new InterruptedException();
				AbstractTreeIterator compareVersionIterator = tw.getTree(
						compareTreeIndex, AbstractTreeIterator.class);
				AbstractTreeIterator baseVersionIterator = tw.getTree(
						baseTreeIndex, AbstractTreeIterator.class);

				IFileRevision left = null;
				IFileRevision right = null;
				String repoRelativePath = baseVersionIterator != null
						? baseVersionIterator.getEntryPathString()
						: compareVersionIterator.getEntryPathString();
				IPath currentPath = new Path(repoRelativePath);

				// Updating the progress bar is slow, so just sample it. To
				// make sure slow compares are reflected in the progress
				// monitor also update before comparing large files.
				long currentTimeMilliseconds = System.currentTimeMillis();
				long size1 = -1;
				long size2 = -1;
				if (compareVersionIterator != null
						&& baseVersionIterator != null) {
					size1 = getEntrySize(tw, compareVersionIterator);
					size2 = getEntrySize(tw, baseVersionIterator);
				}
				final long REPORTSIZE = 100000;
				if (size1 > REPORTSIZE
						|| size2 > REPORTSIZE
						|| currentTimeMilliseconds - previousTimeMilliseconds > 500) {
					monitor.setTaskName(currentPath.toString());
					previousTimeMilliseconds = currentTimeMilliseconds;
				}

				Type type = null;
				if (compareVersionIterator != null
						&& baseVersionIterator != null) {
					boolean equalContent = compareVersionIterator
							.getEntryObjectId().equals(
									baseVersionIterator.getEntryObjectId());
					type = equalContent ? Type.FILE_BOTH_SIDES_SAME
							: Type.FILE_BOTH_SIDES_DIFFER;
				} else if (compareVersionIterator != null
						&& baseVersionIterator == null) {
					type = Type.FILE_DELETED;
				} else if (compareVersionIterator == null
						&& baseVersionIterator != null) {
					type = Type.FILE_ADDED;
				}

				IFile file = null;
				if (type != Type.FILE_BOTH_SIDES_SAME) {

					file = ResourceUtil.getFileForLocation(repository,
						repoRelativePath, false);
				}

				if (baseVersionIterator != null) {
					if (baseCommit == null) {
						if (file != null)
							left = new LocalFileRevision(file);
						else {
							IPath path = getRepositoryPath().append(
									repoRelativePath);
							left = new WorkingTreeFileRevision(
									path.toFile());
						}
					} else {
						left = GitFileRevision
								.inCommit(repository, baseCommit,
										repoRelativePath,
										tw.getObjectId(baseTreeIndex));
					}
				}

				if (compareVersionIterator != null) {
					if (!useIndex)
						right = GitFileRevision.inCommit(repository,
								compareCommit, repoRelativePath,
								tw.getObjectId(compareTreeIndex));
					else
						right = GitFileRevision.inIndex(repository,
								repoRelativePath);
				}

				IPath containerPath = currentPath.removeLastSegments(1);
				ContainerNode containerNode = getOrCreateContainerNode(
						containerPath, type);

				FileNode fileNode = new FileNode(currentPath, file, type, left,
						right);
				containerNode.addChild(fileNode);
				fileNodes.put(currentPath, fileNode);

				// If a file is not "equal content", the container nodes up to
				// the root must be shown in any case, so propagate the
				// change of the "only equal content" flag.
				if (type != Type.FILE_BOTH_SIDES_SAME) {
					IPath path = currentPath;
					while (path.segmentCount() > 0) {
						path = path.removeLastSegments(1);
						ContainerNode node = containerNodes.get(path);
						node.setOnlyEqualContent(false);
					}
				}
			}
		} finally {
			monitor.done();
		}
	}

