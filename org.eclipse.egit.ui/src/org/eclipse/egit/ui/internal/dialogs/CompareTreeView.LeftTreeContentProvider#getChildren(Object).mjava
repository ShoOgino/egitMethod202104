		public Object[] getChildren(Object parentElement) {
			IPath parent = ((PathNode) parentElement).path;
			List<PathNode> children = new ArrayList<PathNode>();
			for (IPath childPath : leftPathsWithChildren) {
				if (childPath.segmentCount() > 0
						&& childPath.removeLastSegments(1).equals(parent)) {
					children.add(new PathNode(childPath, Type.FOLDER));
				}
			}
			for (IPath mapPath : leftVersionMap.keySet()) {
				if (mapPath.removeLastSegments(1).equals(parent)
						&& (!showAddedOnly || leftOnly.contains(mapPath))
						&& (showEquals || !equalIds.contains(mapPath))) {
					if (leftOnly.contains(mapPath))
						children.add(new PathNode(mapPath, Type.FILE_ADDED));
					else if (equalIds.contains(mapPath))
						children.add(new PathNode(mapPath,
								Type.FILE_BOTH_SIDES_SAME));
					else
						children.add(new PathNode(mapPath,
								Type.FILE_BOTH_SIDES_DIFFER));
				}
			}
			Collections.sort(children, new Comparator<PathNode>() {
				public int compare(PathNode o1, PathNode o2) {
					int diff = o1.type.ordinal() - o2.type.ordinal();
					if (diff != 0)
						return diff;
					return o1.path.toString().compareTo(o2.path.toString());
				}
			});
			return children.toArray();
		}

