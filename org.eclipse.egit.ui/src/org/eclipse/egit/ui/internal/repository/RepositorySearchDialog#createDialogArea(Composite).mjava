	@Override
	protected Control createDialogArea(Composite parent) {
		super.createDialogArea(parent);
		setTitle(UIText.RepositorySearchDialog_searchRepositories);
		setMessage(UIText.RepositorySearchDialog_searchRepositoriesMessage);

		Composite main = new Composite(parent, SWT.NONE);
		main.setLayout(new GridLayout(4, false));
		main.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));

		Label dirLabel = new Label(main, SWT.NONE);
		dirLabel.setText(UIText.RepositorySearchDialog_directory);
		dir = new Text(main, SWT.BORDER);
		GridDataFactory.fillDefaults().align(SWT.FILL, SWT.CENTER).grab(true,
				false).span(2, 1).hint(300, SWT.DEFAULT).applyTo(dir);

		String initialPath = prefs.get(PREF_PATH, ResourcesPlugin
				.getWorkspace().getRoot().getLocation().toOSString());

		dir.setText(initialPath);

		Button browse = new Button(main, SWT.PUSH);
		browse.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, false, false,
				1, 1));
		browse.setText(UIText.RepositorySearchDialog_browse);
		browse.addSelectionListener(new SelectionAdapter() {

			@Override
			public void widgetSelected(SelectionEvent e) {
				DirectoryDialog dd = new DirectoryDialog(getShell());
				dd.setFilterPath(dir.getText());
				String directory = dd.open();
				if (directory != null) {
					dir.setText(directory);
					prefs.put(PREF_PATH, directory);
					try {
						prefs.flush();
					} catch (BackingStoreException e1) {
						// ignore here
					}
				}
			}

		});

		// TODO for 3.4 compatibility, we must use this constructor
		fTree = new FilteredTree(main, SWT.CHECK | SWT.BORDER,
				new PatternFilter());
		fTreeViewer = fTree.getViewer();
		fTreeViewer
				.addSelectionChangedListener(new ISelectionChangedListener() {

					public void selectionChanged(SelectionChangedEvent event) {
						// this is used to update the OK button when the
						// keyboard
						// is used to toggle the check boxes
						getButton(OK).setEnabled(hasCheckedItems());
					}
				});

		GridDataFactory.fillDefaults().grab(true, true).span(4, 1).minSize(0,
				300).applyTo(fTree);
		fTree.setEnabled(false);

		lookForNestedButton = new Button(main, SWT.CHECK);
		lookForNestedButton.setLayoutData(new GridData(SWT.LEFT, SWT.CENTER,
				false, false, 2, 1));
		lookForNestedButton.setSelection(prefs.getBoolean(PREF_DEEP_SEARCH,
				false));
		lookForNestedButton
				.setText(UIText.RepositorySearchDialog_DeepSearch_button);

		lookForNestedButton.addSelectionListener(new SelectionAdapter() {

			@Override
			public void widgetSelected(SelectionEvent e) {
				prefs.putBoolean(PREF_DEEP_SEARCH, lookForNestedButton
						.getSelection());
				try {
					prefs.flush();
				} catch (BackingStoreException e1) {
					// ignore
				}
				doSearch();
			}

		});

		fSelectAllButton = new Button(main, SWT.NONE);
		fSelectAllButton.setLayoutData(new GridData(SWT.RIGHT, SWT.TOP, false,
				false, 1, 1));
		fSelectAllButton
				.setText(UIText.RepositorySearchDialog_SelectAll_button);
		fSelectAllButton.setEnabled(false);
		fSelectAllButton.addSelectionListener(new SelectionAdapter() {

			@Override
			public void widgetSelected(SelectionEvent e) {
				setAllSelected(true);
			}
		});

		fDeselectAllButton = new Button(main, SWT.NONE);
		fDeselectAllButton.setLayoutData(new GridData(SWT.RIGHT, SWT.TOP,
				false, false, 1, 1));
		fDeselectAllButton
				.setText(UIText.RepositorySearchDialog_DeselectAll_button);
		fDeselectAllButton.setEnabled(false);
		fDeselectAllButton.addSelectionListener(new SelectionAdapter() {

			@Override
			public void widgetSelected(SelectionEvent e) {
				setAllSelected(false);
			}
		});

		// TODO this isn't the most optimal way of handling this... ideally we
		// should have some type of delay
		// if we could use databinding an observeDelayedValue would totally work
		// here
		dir.addModifyListener(new ModifyListener() {

			public void modifyText(ModifyEvent e) {
				doSearch();
			}

		});

		fTreeViewer.setContentProvider(new ContentProvider());
		fTreeViewer.setLabelProvider(new RepositoryLabelProvider());

		return main;
	}

