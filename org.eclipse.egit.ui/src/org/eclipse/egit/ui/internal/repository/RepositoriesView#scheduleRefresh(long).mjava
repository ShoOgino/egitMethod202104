	private Job scheduleRefresh(long delay) {
		if (GitTraceLocation.REPOSITORIESVIEW.isActive()) {
			trace("Entering scheduleRefresh()"); //$NON-NLS-1$
		}

		if (scheduledJob != null) {
			schedule(scheduledJob, delay);
			return scheduledJob;
		}

		Job job = new Job("Refreshing Git Repositories view") { //$NON-NLS-1$

			@Override
			protected IStatus run(IProgressMonitor monitor) {
				final CommonViewer tv = getCommonViewer();
				if (!UIUtils.isUsable(tv)) {
					return Status.CANCEL_STATUS;
				}
				final boolean trace = GitTraceLocation.REPOSITORIESVIEW
						.isActive();
				final boolean needsNewInput = lastInputChange > lastInputUpdate;
				if (trace) {
					trace("Running the update, new input required: " //$NON-NLS-1$
									+ (lastInputChange > lastInputUpdate));
				}
				lastInputUpdate = System.currentTimeMillis();
				if (needsNewInput) {
					initRepositoriesAndListeners();
				}

				PlatformUI.getWorkbench().getDisplay()
						.syncExec(new Runnable() {
					@Override
					public void run() {
						if (!UIUtils.isUsable(tv)) {
							return;
						}
						long start = 0;
						if (trace) {
							start = System.currentTimeMillis();
							trace("Starting async update job"); //$NON-NLS-1$
						}

						if (needsNewInput) {
							// keep expansion state and selection so that we can
							// restore the tree
							// after update
							Object[] expanded = tv.getExpandedElements();
							tv.setInput(ResourcesPlugin.getWorkspace()
									.getRoot());
							tv.setExpandedElements(expanded);
						} else {
							tv.refresh(true);
						}

						IViewPart part = PlatformUI.getWorkbench()
								.getActiveWorkbenchWindow().getActivePage()
								.findView(IPageLayout.ID_PROP_SHEET);
						if (part instanceof PropertySheet) {
							PropertySheet sheet = (PropertySheet) part;
							IPage page = sheet.getCurrentPage();
							if (page instanceof PropertySheetPage) {
								((PropertySheetPage) page).refresh();
							}
						}
						if (trace) {
							trace("Ending async update job after " //$NON-NLS-1$
									+ (System.currentTimeMillis() - start)
									+ " ms"); //$NON-NLS-1$
						}
						if (!repositories.isEmpty()) {
							layout.topControl = getCommonViewer().getControl();
						} else {
							layout.topControl = emptyArea;
						}
						emptyArea.getParent().layout(true, true);
					}
				});
				if (monitor.isCanceled()) {
					return Status.CANCEL_STATUS;
				}
				return Status.OK_STATUS;
			}

			@Override
			public boolean belongsTo(Object family) {
				return JobFamilies.REPO_VIEW_REFRESH.equals(family);
			}

		};
		job.setSystem(true);

		schedule(job, delay);

		scheduledJob = job;
		return scheduledJob;
	}

