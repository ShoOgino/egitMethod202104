	private void handleSingleRepositoryCheckoutOperationResult(Repository repository,
			CheckoutResult result) {

		if (result.getStatus() == CheckoutResult.Status.CONFLICTS) {
			PlatformUI.getWorkbench().getDisplay().asyncExec(() -> {
				Shell shell = PlatformUI.getWorkbench()
						.getActiveWorkbenchWindow().getShell();
					CleanupUncomittedChangesDialog cleanupUncomittedChangesDialog = new CleanupUncomittedChangesDialog(
						shell, UIText.BranchResultDialog_CheckoutConflictsTitle,
						NLS.bind(
								UIText.BranchResultDialog_CheckoutConflictsMessage,
								Repository.shortenRefName(target)),
						repository, result.getConflictList());
				cleanupUncomittedChangesDialog.open();
				if (cleanupUncomittedChangesDialog.shouldContinue()) {
					BranchOperationUI.checkout(repository, target, false)
							.start();
					}
			});
		} else if (result.getStatus() == CheckoutResult.Status.NONDELETED) {
			// double-check if the files are still there
			boolean show = false;
			List<String> pathList = result.getUndeletedList();
			for (String path : pathList)
				if (new File(repository.getWorkTree(), path).exists()) {
					show = true;
					break;
				}

			if (!show)
				return;

			PlatformUI.getWorkbench().getDisplay().asyncExec(() -> {
					Shell shell = PlatformUI.getWorkbench()
							.getActiveWorkbenchWindow().getShell();
					new NonDeletedFilesDialog(shell, repository,
							result.getUndeletedList()).open();
			});
		} else {

			String repoName = Activator.getDefault().getRepositoryUtil()
					.getRepositoryName(repository);
			String message = NLS.bind(
					UIText.BranchOperationUI_CheckoutError_DialogMessage,
					repoName, target);
			PlatformUI.getWorkbench().getDisplay().asyncExec(() -> {
				Shell shell = PlatformUI.getWorkbench()
						.getActiveWorkbenchWindow().getShell();
				MessageDialog.openError(shell,
						UIText.BranchOperationUI_CheckoutError_DialogTitle,
						message);
			});
		}
	}

