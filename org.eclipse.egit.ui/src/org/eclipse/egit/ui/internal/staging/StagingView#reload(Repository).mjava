	/**
	 * Reload the staging view asynchronously
	 *
	 * @param repository
	 */
	public void reload(final Repository repository) {
		if (isDisposed()) {
			return;
		}
		if (repository == null) {
			asyncExec(new Runnable() {
				@Override
				public void run() {
					clearRepository(null);
				}
			});
			return;
		}

		if (!isValidRepo(repository)) {
			asyncExec(new Runnable() {
				@Override
				public void run() {
					clearRepository(repository);
				}
			});
			return;
		}

		final boolean repositoryChanged = currentRepository != repository;
		currentRepository = repository;

		asyncExec(new Runnable() {

			@Override
			public void run() {
				if (isDisposed()) {
					return;
				}

				final IndexDiffData indexDiff = doReload(repository);
				boolean indexDiffAvailable = indexDiffAvailable(indexDiff);
				boolean noConflicts = noConflicts(indexDiff);

				if (repositoryChanged) {
					// Reset paths, they're from the old repository
					resetPathsToExpand();
					if (refsChangedListener != null)
						refsChangedListener.remove();
					refsChangedListener = repository.getListenerList()
							.addRefsChangedListener(new RefsChangedListener() {

								@Override
								public void onRefsChanged(RefsChangedEvent event) {
									updateRebaseButtonVisibility(repository
											.getRepositoryState().isRebasing());
								}

							});
				}
				final StagingViewUpdate update = new StagingViewUpdate(repository, indexDiff, null);
				Object[] unstagedExpanded = unstagedViewer
						.getExpandedElements();
				Object[] stagedExpanded = stagedViewer
						.getExpandedElements();

				int elementsCount = updateAutoExpand(unstagedViewer,
						getUnstaged(indexDiff));
				elementsCount += updateAutoExpand(stagedViewer,
						getStaged(indexDiff));

				if (elementsCount > getMaxLimitForListMode()) {
					listPresentationAction.setEnabled(false);
					if (presentation == Presentation.LIST) {
						compactTreePresentationAction.setChecked(true);
						switchToCompactModeInternal(true);
					} else {
						setExpandCollapseActionsVisible(false);
					}
				} else {
					listPresentationAction.setEnabled(true);
					boolean changed = getPreferenceStore().getBoolean(
							UIPreferences.STAGING_VIEW_PRESENTATION_CHANGED);
					if (changed) {
						listPresentationAction.setChecked(true);
						listPresentationAction.run();
					} else if (presentation != Presentation.LIST) {
						setExpandCollapseActionsVisible(true);
					}
				}

				unstagedViewer.setInput(update);
				stagedViewer.setInput(update);
				expandPreviousExpandedAndPaths(unstagedExpanded, unstagedViewer,
						pathsToExpandInUnstaged);
				expandPreviousExpandedAndPaths(stagedExpanded, stagedViewer,
						pathsToExpandInStaged);
				refreshAction.setEnabled(true);

				updateRebaseButtonVisibility(repository.getRepositoryState()
						.isRebasing());

				updateIgnoreErrorsButtonVisibility();

				boolean rebaseContinueEnabled = indexDiffAvailable
						&& repository.getRepositoryState().isRebasing()
						&& noConflicts;
				rebaseContinueButton.setEnabled(rebaseContinueEnabled);

				form.setText(GitLabels.getStyledLabelSafe(repository).toString());
				updateCommitMessageComponent(repositoryChanged, indexDiffAvailable);
				enableCommitWidgets(indexDiffAvailable && noConflicts);

				updateCommitButtons();
				updateSectionText();
			}

		});
	}

