	private void commit() {
		if (stagedTableViewer.getTable().getItemCount() == 0
				&& !amendPreviousCommitAction.isChecked()) {
			MessageDialog.openError(getSite().getShell(),
					UIText.StagingView_committingNotPossible,
					UIText.StagingView_noStagedFiles);
			return;
		}
		if (!commitMessageComponent.checkCommitInfo())
			return;
		final Repository repository = currentRepository;
		CommitOperation commitOperation = null;
		try {
			commitOperation = new CommitOperation(repository,
					commitMessageComponent.getAuthor(),
					commitMessageComponent.getCommitter(),
					commitMessageComponent.getCommitMessage()) {

				protected RevCommit commit() throws TeamException {
					RevCommit commit = super.commit();
					openNewCommit(commit);
					return commit;
				}

				protected RevCommit commitAll(Date commitDate,
						TimeZone timeZone, PersonIdent authorIdent,
						PersonIdent committerIdent) throws TeamException {
					RevCommit commit = super.commitAll(commitDate, timeZone,
							authorIdent, committerIdent);
					openNewCommit(commit);
					return commit;
				}

				private void openNewCommit(final RevCommit newCommit) {
					if (newCommit != null && openNewCommitsAction.isChecked())
						asyncExec(new Runnable() {

							public void run() {
								CommitEditor.openQuiet(new RepositoryCommit(
										repository, newCommit));
							}
						});
				}

			};
		} catch (CoreException e) {
			Activator.handleError(UIText.StagingView_commitFailed, e, true);
			return;
		}
		if (amendPreviousCommitAction.isChecked())
			commitOperation.setAmending(true);
		commitOperation.setComputeChangeId(addChangeIdAction.isChecked());
		CommitUI.performCommit(currentRepository, commitOperation);
		clearCommitMessageToggles();
		commitMessageText.setText(EMPTY_STRING);
	}

