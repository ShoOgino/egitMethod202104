	static FileDiff[] compute(final TreeWalk walk, final RevCommit commit)
			throws MissingObjectException, IncorrectObjectTypeException,
			CorruptObjectException, IOException {
		final ArrayList<FileDiff> r = new ArrayList<FileDiff>();

		walk.reset(trees(commit));
		final int nTree = walk.getTreeCount();
		final int myTree = nTree - 1;

		switch (nTree) {
		case 1:
			while (walk.next()) {
				final FileDiff d = new FileDiff(commit, walk.getPathString());
				d.change = "A";
				d.blobs = new ObjectId[] { walk.getObjectId(0) };
				r.add(d);
			}
			break;
		case 2:
			while (walk.next()) {
				final FileDiff d = new FileDiff(commit, walk.getPathString());
				final ObjectId id0 = walk.getObjectId(0);
				final ObjectId id1 = walk.getObjectId(1);
				d.change = "M";
				d.blobs = new ObjectId[] { id0, id1 };

				final int m0 = walk.getRawMode(0);
				final int m1 = walk.getRawMode(1);
				if (m0 == 0 && m1 != 0)
					d.change = "A";
				else if (m0 != 0 && m1 == 0)
					d.change = "D";
				else if (m0 != m1 && walk.idEqual(0, 1))
					d.change = "T";
				r.add(d);
			}
			break;
		default:
			while (walk.next()) {
				if (matchAnyParent(walk, myTree))
					continue;

				final FileDiff d = new FileDiff(commit, walk.getPathString());
				int m0 = 0;
				for (int i = 0; i < myTree; i++)
					m0 |= walk.getRawMode(i);
				final int m1 = walk.getRawMode(myTree);
				d.change = "M";
				if (m0 == 0 && m1 != 0)
					d.change = "A";
				else if (m0 != 0 && m1 == 0)
					d.change = "D";
				else if (m0 != m1 && walk.idEqual(0, myTree))
					d.change = "T";
				d.blobs = new ObjectId[nTree];
				for (int i = 0; i < nTree; i++)
					d.blobs[i] = walk.getObjectId(i);
				r.add(d);
			}
			break;
		}

		final FileDiff[] tmp = new FileDiff[r.size()];
		r.toArray(tmp);
		return tmp;
	}

