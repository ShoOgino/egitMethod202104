	@Override
	public boolean inputSet() {
		cancelRefreshJob();

		if (this.input != null)
			return true;

		setErrorMessage(null);
		if (currentWalk != null)
			currentWalk.release();
		currentWalk = null;
		Object o = super.getInput();
		if (o == null) {
			setErrorMessage(UIText.GitHistoryPage_NoInputMessage);
			return false;
		}

		if (o instanceof IResource) {
			RepositoryMapping mapping = RepositoryMapping
					.getMapping((IResource) o);
			if (mapping != null) {
				Repository repo = mapping.getRepository();
				input = new HistoryPageInput(repo,
						new IResource[] { (IResource) o });
			}
		} else if (o instanceof RepositoryTreeNode) {
			RepositoryTreeNode repoNode = (RepositoryTreeNode) o;
			switch (repoNode.getType()) {
			case FILE:
				File file = ((FileNode) repoNode).getObject();
				input = new HistoryPageInput(repoNode.getRepository(),
						new File[] { file });
				break;
			case FOLDER:
				File folder = ((FolderNode) repoNode).getObject();
				input = new HistoryPageInput(repoNode.getRepository(),
						new File[] { folder });
				break;
			default:
				input = new HistoryPageInput(repoNode.getRepository());
			}

		} else if (o instanceof HistoryPageInput)
			input = (HistoryPageInput) o;
		else if (o instanceof IAdaptable) {
			IResource resource = (IResource) ((IAdaptable) o)
					.getAdapter(IResource.class);
			if (resource != null) {
				RepositoryMapping mapping = RepositoryMapping
						.getMapping((IResource) o);
				Repository repo = mapping.getRepository();
				input = new HistoryPageInput(repo, new IResource[] { resource });
			}
		}
		if (input == null) {
			this.name = ""; //$NON-NLS-1$
			setErrorMessage(UIText.GitHistoryPage_NoInputMessage);
			return false;
		}

		final IResource[] inResources = input.getItems();
		final File[] inFiles = input.getFileList();
		if (inResources != null && inResources.length == 0) {
			this.name = ""; //$NON-NLS-1$
			setErrorMessage(UIText.GitHistoryPage_NoInputMessage);
			return false;
		}

		this.name = calcluateName(input);

		final Repository db = input.getRepository();

		final ArrayList<String> paths;
		if (inResources != null) {
			paths = new ArrayList<String>(inResources.length);
			for (final IResource r : inResources) {
				final RepositoryMapping map = RepositoryMapping.getMapping(r);
				if (map == null)
					continue;
				if (db != map.getRepository()) {
					setErrorMessage(UIText.AbstractHistoryCommanndHandler_NoUniqueRepository);
					return false;
				}

				if (showAllFilter == ShowFilter.SHOWALLFOLDER) {
					final String path = map.getRepoRelativePath(r.getParent());
					if (path != null && path.length() > 0)
						paths.add(path);
				} else if (showAllFilter == ShowFilter.SHOWALLPROJECT) {
					final String path = map.getRepoRelativePath(r.getProject());
					if (path != null && path.length() > 0)
						paths.add(path);
				} else if (showAllFilter == ShowFilter.SHOWALLREPO) {
					// nothing
				} else /* if (showAllFilter == ShowFilter.SHOWALLRESOURCE) */{
					final String path = map.getRepoRelativePath(r);
					if (path != null && path.length() > 0)
						paths.add(path);
				}
			}
		} else if (inFiles != null) {
			IPath workdirPath = new Path(db.getWorkTree().getPath());
			IPath gitDirPath = new Path(db.getDirectory().getPath());
			int segmentCount = workdirPath.segmentCount();
			paths = new ArrayList<String>(inFiles.length);
			for (File file : inFiles) {
				IPath filePath;
				if (showAllFilter == ShowFilter.SHOWALLFOLDER) {
					filePath = new Path(file.getParentFile().getPath());
				} else if (showAllFilter == ShowFilter.SHOWALLPROJECT
						|| showAllFilter == ShowFilter.SHOWALLREPO) {
					// we don't know of projects here -> treat as SHOWALLREPO
					continue;
				} else /* if (showAllFilter == ShowFilter.SHOWALLRESOURCE) */{
					filePath = new Path(file.getPath());
				}

				if (gitDirPath.isPrefixOf(filePath)) {
					setErrorMessage(NLS
							.bind(
									UIText.GitHistoryPage_FileOrFolderPartOfGitDirMessage,
									filePath.toOSString()));
					return false;
				}

				IPath pathToAdd = filePath.removeFirstSegments(segmentCount)
						.setDevice(null);
				if (!pathToAdd.isEmpty()) {
					paths.add(pathToAdd.toString());
				}
			}
		} else {
			paths = new ArrayList<String>(0);
		}
		// disable the filters if we have a Repository as input
		boolean filtersActive = inResources != null || inFiles != null;
		showAllRepoVersionsAction.setEnabled(filtersActive);
		showAllProjectVersionsAction.setEnabled(filtersActive);
		// the repository itself has no notion of projects
		showAllFolderVersionsAction.setEnabled(inResources != null);
		showAllResourceVersionsAction.setEnabled(filtersActive);

		final AnyObjectId headId;
		try {
			headId = db.resolve(Constants.HEAD);
		} catch (IOException e) {
			String errorMessage = NLS.bind(
					UIText.GitHistoryPage_errorParsingHead, db.getDirectory()
							.getAbsolutePath());
			setErrorMessage(errorMessage);
			return false;
		}

		if (headId == null) {
			String errorMessage = NLS.bind(
					UIText.GitHistoryPage_errorParsingHead, Activator
							.getDefault().getRepositoryUtil()
							.getRepositoryName(db));
			setErrorMessage(errorMessage);
			return false;
		}

		if (pathChange(pathFilters, paths) || currentWalk == null
				|| !headId.equals(currentHeadId)) {
			// TODO Do not dispose SWTWalk just because HEAD changed
			// In theory we should be able to update the graph and
			// not dispose of the SWTWalk, even if HEAD was reset to
			// HEAD^1 and the old HEAD commit should not be visible.
			//
			currentHeadId = headId;
			if (currentWalk != null)
				currentWalk.release();
			currentWalk = new SWTWalk(db);
			currentWalk.sort(RevSort.COMMIT_TIME_DESC, true);
			currentWalk.sort(RevSort.BOUNDARY, true);
			highlightFlag = currentWalk.newFlag("highlight"); //$NON-NLS-1$
		} else {
			currentWalk.reset();
		}

		try {
			if (store.getBoolean(UIPreferences.RESOURCEHISTORY_SHOW_ALL_BRANCHES)) {
				markStartAllRefs(Constants.R_HEADS);
				markStartAllRefs(Constants.R_REMOTES);
			} else
				currentWalk.markStart(currentWalk.parseCommit(headId));
		} catch (IOException e) {
			Activator.logError(NLS.bind(
					UIText.GitHistoryPage_errorReadingHeadCommit, headId, db
							.getDirectory().getAbsolutePath()), e);
			return false;
		}

		final TreeWalk fileWalker = new TreeWalk(db);
		fileWalker.setRecursive(true);
		if (paths.size() > 0) {
			pathFilters = paths;
			currentWalk.setTreeFilter(AndTreeFilter.create(PathFilterGroup
					.createFromStrings(paths), TreeFilter.ANY_DIFF));
			fileWalker.setFilter(currentWalk.getTreeFilter().clone());

		} else {
			pathFilters = null;
			currentWalk.setTreeFilter(TreeFilter.ALL);
			fileWalker.setFilter(TreeFilter.ANY_DIFF);
		}
		fileViewer.setTreeWalk(db, fileWalker);
		fileViewer.addSelectionChangedListener(commentViewer);
		commentViewer.setTreeWalk(fileWalker);
		commentViewer.setDb(db);
		findToolbar.clear();
		graph.setInput(highlightFlag, null, null);

		final SWTCommitList list;
		list = new SWTCommitList(graph.getControl().getDisplay());
		list.source(currentWalk);

		final GenerateHistoryJob rj = new GenerateHistoryJob(this, list);
		rj.addJobChangeListener(new JobChangeAdapter() {
			@Override
			public void done(final IJobChangeEvent event) {
				final Control graphctl = graph.getControl();
				if (job != rj || graphctl.isDisposed())
					return;
				graphctl.getDisplay().asyncExec(new Runnable() {
					public void run() {
						if (job == rj)
							job = null;
					}
				});
			}
		});
		job = rj;
		schedule(rj);
		return true;
	}

