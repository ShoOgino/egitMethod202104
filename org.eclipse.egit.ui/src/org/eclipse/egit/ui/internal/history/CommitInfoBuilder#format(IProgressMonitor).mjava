	/**
	 * Retrieves and formats the commit info.
	 *
	 * @param monitor
	 *            for progress reporting and cancellation
	 * @return formatted commit info
	 * @throws IOException
	 */
	public FormatResult format(IProgressMonitor monitor) throws IOException {
		boolean trace = GitTraceLocation.HISTORYVIEW.isActive();
		if (trace)
			GitTraceLocation.getTrace().traceEntry(
					GitTraceLocation.HISTORYVIEW.getLocation());
		monitor.setTaskName(UIText.CommitMessageViewer_FormattingMessageTaskName);
		final StringBuilder d = new StringBuilder();
		final PersonIdent author = commit.getAuthorIdent();
		final PersonIdent committer = commit.getCommitterIdent();
		List<GitCommitReference> hyperlinks = new ArrayList<>();
		d.append(UIText.CommitMessageViewer_commit);
		d.append(' ');
		d.append(commit.getId().name());
		d.append(LF);

		addPersonIdent(d, author, UIText.CommitMessageViewer_author);
		addPersonIdent(d, committer, UIText.CommitMessageViewer_committer);

		for (int i = 0; i < commit.getParentCount(); i++) {
			addCommit(d, (SWTCommit) commit.getParent(i),
					UIText.CommitMessageViewer_parent, hyperlinks);
		}

		for (int i = 0; i < commit.getChildCount(); i++) {
			addCommit(d, (SWTCommit) commit.getChild(i),
					UIText.CommitMessageViewer_child, hyperlinks);
		}

		if(Activator.getDefault().getPreferenceStore().getBoolean(
				UIPreferences.HISTORY_SHOW_BRANCH_SEQUENCE)) {
			try (RevWalk rw = new RevWalk(db)) {
				List<Ref> branches = getBranches(commit, allRefs, db);
				if (!branches.isEmpty()) {
					d.append(UIText.CommitMessageViewer_branches);
					d.append(": "); //$NON-NLS-1$
					int count = 0;
					for (Iterator<Ref> i = branches.iterator(); i.hasNext();) {
						Ref head = i.next();
						RevCommit p;
						p = rw.parseCommit(head.getObjectId());
						addLink(d, formatHeadRef(head), hyperlinks, p);
						if (i.hasNext()) {
							if (count++ <= MAXBRANCHES) {
								d.append(", "); //$NON-NLS-1$
							} else {
								d.append(NLS.bind(UIText.CommitMessageViewer_MoreBranches, Integer.valueOf(branches.size() - MAXBRANCHES)));
								break;
							}
						}
					}
					d.append(LF);
				}
			} catch (IOException e) {
				Activator.logError(e.getMessage(), e);
			}
		}

		String tagsString = getTagsString();
		if (tagsString.length() > 0) {
			d.append(UIText.CommitMessageViewer_tags);
			d.append(": "); //$NON-NLS-1$
			d.append(tagsString);
			d.append(LF);
		}

		if (Activator.getDefault().getPreferenceStore().getBoolean(
				UIPreferences.HISTORY_SHOW_TAG_SEQUENCE)) {
			try (RevWalk rw = new RevWalk(db)) {
				monitor.setTaskName(UIText.CommitMessageViewer_GettingPreviousTagTaskName);
				addTag(d, UIText.CommitMessageViewer_follows, rw,
						getNextTag(false, monitor), hyperlinks);
			} catch (IOException e) {
				Activator.logError(e.getMessage(), e);
			}

			try (RevWalk rw = new RevWalk(db)) {
				monitor.setTaskName(UIText.CommitMessageViewer_GettingNextTagTaskName);
				addTag(d, UIText.CommitMessageViewer_precedes, rw,
						getNextTag(true, monitor), hyperlinks);
			} catch (IOException e) {
				Activator.logError(e.getMessage(), e);
			}
		}

		d.append(LF);
		int headerEnd = d.length();
		String msg = commit.getFullMessage().trim();
		// Find start of footer:
		Matcher spm = FOOTER_PATTERN.matcher(msg);
		int footerStart = -1;
		if (spm.find()) {
			if (fill) {
				String footer = msg.substring(spm.start());
				msg = msg.substring(0, spm.start());
				msg = msg.replaceAll("([\\w.,; \t])\n(\\w)", "$1 $2") //$NON-NLS-1$ //$NON-NLS-2$
						+ footer;
				footerStart = headerEnd + msg.length() - footer.length();
			} else {
				footerStart = headerEnd + spm.start();
			}
		} else if (fill) {
			msg = msg.replaceAll("([\\w.,; \t])\n(\\w)", "$1 $2"); //$NON-NLS-1$ //$NON-NLS-2$
		}

		d.append(msg);
		if (!msg.endsWith(LF))
			d.append(LF);

		if (trace)
			GitTraceLocation.getTrace().traceExit(
					GitTraceLocation.HISTORYVIEW.getLocation());
		return new FormatResult(d.toString(), hyperlinks, headerEnd,
				footerStart >= 0 ? footerStart : d.length());
	}

