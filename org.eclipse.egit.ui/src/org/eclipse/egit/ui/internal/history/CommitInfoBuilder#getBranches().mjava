	/**
	 * @return List of heads from those current commit is reachable
	 */
	private List<Ref> getBranches() {
		RevWalk revWalk = new RevWalk(db);
		List<Ref> result = new ArrayList<Ref>();

		try {
			// searches from branches can be cut off early if any parent of the
			// search-for commit is found. This is quite likely, so optimize for this.
			revWalk.markStart(Arrays.asList(commit.getParents()));
			ObjectIdSubclassMap<ObjectId> cutOff = new ObjectIdSubclassMap<ObjectId>();
			Map<String, Ref> refsMap = new HashMap<String, Ref>();
			refsMap.putAll(db.getRefDatabase().getRefs(Constants.R_HEADS));
			// add remote heads to search
			refsMap.putAll(db.getRefDatabase().getRefs(Constants.R_REMOTES));

			final int SKEW = 24*3600; // one day clock skew

			for (Ref ref : refsMap.values()) {
				RevCommit headCommit = revWalk.parseCommit(ref.getObjectId());

				// if commit is in the ref branch, then the tip of ref should be
				// newer than the commit we are looking for. Allow for a large
				// clock skew.
				if (headCommit.getCommitTime() + SKEW < commit.getCommitTime())
					continue;

				List<ObjectId> maybeCutOff = new ArrayList<ObjectId>(cutOff.size()); // guess rough size
				revWalk.resetRetain();
				revWalk.markStart(headCommit);
				RevCommit current;
				Ref found = null;
				while ((current = revWalk.next()) != null) {
					if (AnyObjectId.equals(current, commit)) {
						found = ref;
						break;
					}
					if (cutOff.contains(current))
						break;
					maybeCutOff.add(current.toObjectId());
				}
				if (found != null)
					result.add(ref);
				else
					for (ObjectId id : maybeCutOff)
						cutOff.addIfAbsent(id);

			}
			revWalk.dispose();
		} catch (IOException e) {
			// skip exception
		}
		return result;
	}

