		@Override
		public IStatus runInWorkspace(IProgressMonitor monitor) {
			Set<Repository> repos;
			synchronized (repositoriesChanged) {
				if (repositoriesChanged.isEmpty()) {
					return Status.OK_STATUS;
				}
				repos = new LinkedHashSet<>(repositoriesChanged);
				repositoriesChanged.clear();
			}
			IProject[] projects = ResourcesPlugin.getWorkspace().getRoot()
					.getProjects();
			Set<IProject> toRefresh = new LinkedHashSet<>();
			for (IProject p : projects) {
				if (!p.isAccessible()) {
					continue;
				}
				RepositoryMapping mapping = RepositoryMapping.getMapping(p);
				if (mapping != null
						&& repos.contains(mapping.getRepository())) {
					toRefresh.add(p);
				}
			}
			monitor.beginTask(UIText.Activator_refreshingProjects,
					toRefresh.size());

			for (IProject p : toRefresh) {
				if (monitor.isCanceled()) {
					return Status.CANCEL_STATUS;
				}
				ISchedulingRule rule = p.getWorkspace().getRuleFactory().refreshRule(p);
				try {
					getJobManager().beginRule(rule, monitor);
					// handle missing projects after branch switch
					if (p.isAccessible()) {
						p.refreshLocal(IResource.DEPTH_INFINITE, new SubProgressMonitor(monitor, 1));
					}
				} catch (CoreException e) {
					handleError(UIText.Activator_refreshFailed, e, false);
					return new Status(IStatus.ERROR, getPluginId(), e.getMessage());
				} finally {
					getJobManager().endRule(rule);
				}
			}
			if (!monitor.isCanceled()) {
				// re-schedule if we got some changes in the meantime
				synchronized (repositoriesChanged) {
					if (!repositoriesChanged.isEmpty()) {
						schedule(100);
					}
				}
			}
			monitor.done();
			return Status.OK_STATUS;
		}

