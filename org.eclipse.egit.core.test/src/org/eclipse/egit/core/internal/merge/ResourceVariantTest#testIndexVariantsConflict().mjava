	@Test
	public void testIndexVariantsConflict() throws Exception {
		File file1 = testRepo.createFile(iProject, "file1");
		IFile iFile1 = testRepo.getIFile(iProject, file1);

		setupConflictingBranches();
		// end setup

		// create a conflict to force multiple stages
		new MergeOperation(repo, BRANCH).execute(null);

		DirCache cache = repo.readDirCache();
		// 3 stages for file 1, 2 stages for file 2
		assertEquals(5, cache.getEntryCount());
		for (int i = 0; i < cache.getEntryCount(); i++) {
			final DirCacheEntry entry = cache.getEntry(i);

			AbstractGitResourceVariant variant = IndexResourceVariant.create(
					repo, entry);
			assertEquals(entry.getObjectId().getName(),
					variant.getContentIdentifier());
			assertEquals(entry.getObjectId(), variant.getObjectId());
			assertEquals(entry.getRawMode(), variant.getRawMode());
			if (iFile1.getName().equals(variant.getName())) {
				switch (entry.getStage()) {
				case DirCacheEntry.STAGE_1:
					assertContentEquals(variant, INITIAL_CONTENT_1);
					break;
				case DirCacheEntry.STAGE_2:
					assertContentEquals(variant, INITIAL_CONTENT_1
							+ MASTER_CHANGE);
					break;
				case DirCacheEntry.STAGE_3:
					assertContentEquals(variant, BRANCH_CHANGE
							+ INITIAL_CONTENT_1);
					break;
				case DirCacheEntry.STAGE_0:
				default:
					fail("Unexpected entry stage " + entry.getStage()
							+ " in the index for file " + entry.getPathString());
					break;
				}
			} else {
				switch (entry.getStage()) {
				case DirCacheEntry.STAGE_2:
					assertContentEquals(variant, INITIAL_CONTENT_2
							+ MASTER_CHANGE);
					break;
				case DirCacheEntry.STAGE_3:
					assertContentEquals(variant, BRANCH_CHANGE
							+ INITIAL_CONTENT_2);
					break;
				case DirCacheEntry.STAGE_0:
				case DirCacheEntry.STAGE_1:
				default:
					fail("Unexpected entry stage " + entry.getStage()
							+ " in the index for file " + entry.getPathString());
					break;
				}
			}
		}
	}

